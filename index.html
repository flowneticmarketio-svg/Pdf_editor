<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SHSSS PDF Tool</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf-lib/1.17.1/pdf-lib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: "Segoe UI", Roboto, sans-serif;
      background: radial-gradient(circle at top left, #0f0f0f, #000000 80%);
      color: #e0e0e0;
      text-align: center;
    }

    h1 {
      font-size: 2.2rem;
      margin: 25px 0;
      color: #76ff03;
      text-shadow: 0 0 15px #76ff03;
      letter-spacing: 2px;
    }

    .container {
      max-width: 950px;
      margin: auto;
      padding: 25px;
      border-radius: 20px;
      background: rgba(20, 20, 20, 0.85);
      box-shadow: 0 0 25px rgba(118, 255, 3, 0.3);
      backdrop-filter: blur(12px);
    }

    input[type="file"] {
      margin: 10px auto;
      padding: 12px;
      border-radius: 10px;
      background: #1a1a1a;
      border: 1px solid #333;
      color: #aaa;
      display: block;
      cursor: pointer;
      transition: all 0.3s;
    }
    input[type="file"]:hover {
      border-color: #76ff03;
      color: #76ff03;
    }

    .options {
      display: grid;
      gap: 12px;
      margin: 20px auto;
      text-align: left;
    }

    .option-card {
      background: #111;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid #222;
      transition: all 0.3s;
      cursor: pointer;
    }
    .option-card:hover {
      border-color: #76ff03;
      box-shadow: 0 0 15px rgba(118, 255, 3, 0.3);
    }

    label {
      cursor: pointer;
      font-size: 14px;
    }

    select, input[type="number"], input[type="range"] {
      background: #1b1b1b;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 5px 8px;
      color: #76ff03;
      font-size: 14px;
      outline: none;
      margin-left: 6px;
    }

    button {
      background: linear-gradient(90deg, #76ff03, #3affb3);
      color: #000;
      font-weight: bold;
      padding: 12px 24px;
      border-radius: 12px;
      border: none;
      cursor: pointer;
      margin: 12px;
      font-size: 15px;
      box-shadow: 0 0 15px rgba(118, 255, 3, 0.4);
      transition: transform 0.2s, box-shadow 0.3s;
    }
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 0 25px rgba(118, 255, 3, 0.7);
    }
    button:disabled {
      background: #555;
      color: #aaa;
      cursor: not-allowed;
      box-shadow: none;
    }

    .progress-bar {
      width: 100%;
      height: 22px;
      background: #222;
      border-radius: 12px;
      margin: 15px 0;
      overflow: hidden;
      box-shadow: inset 0 0 8px #000;
    }
    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #76ff03, #3affb3);
      transition: width 0.4s ease;
      box-shadow: 0 0 12px rgba(118, 255, 3, 0.7);
    }

    #statusText {
      font-size: 15px;
      margin: 8px 0;
      color: #aaa;
    }

    iframe {
      width: 100%;
      height: 520px;
      border-radius: 15px;
      margin-top: 20px;
      background: #000;
      box-shadow: 0 0 25px rgba(0,0,0,0.6);
    }
  </style>
</head>
<body>
  <h1>âš¡ SHSSS Headlines PDF Tool</h1>
  <div class="container">
    <input type="file" id="pdfInput" accept="application/pdf" multiple>

    <div class="options">
      <div class="option-card"><label><input type="checkbox" id="mergePDF"> Merge PDFs</label></div>
      <div class="option-card">
        <label><input type="checkbox" id="splitPDF"> Split PDF at page 
          <input type="number" id="splitPage" value="2" min="2" style="width:60px;">
        </label>
      </div>
      <div class="option-card">
        <label><input type="checkbox" id="invertColors"> Invert Colors</label>
        <div id="invertOptions" style="display:none; margin-left:20px; margin-top:6px;">
          <label><input type="radio" name="invertLevel" value="1" checked> Normal invert</label><br>
          <label><input type="radio" name="invertLevel" value="2"> Strong invert</label><br>
          <label><input type="radio" name="invertLevel" value="3"> Pure B/W</label>
        </div>
      </div>
      <div class="option-card">
        <label>Pages per sheet: 
          <select id="multiplePages">
            <option value="1">1</option>
            <option value="2">2-in-1</option>
            <option value="4">4-in-1</option>
          </select>
        </label>
      </div>
      <div class="option-card">
        <label>Quality: 
          <input type="range" id="qualitySlider" min="10" max="100" value="90">
        </label>
      </div>
    </div>

    <button onclick="processor.start()">ðŸš€ Process PDF</button>
    <button onclick="processor.download()" id="downloadBtn" disabled>â¬‡ Download</button>

    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <p id="statusText">Idle</p>

    <iframe id="pdfPreview"></iframe>
  </div>
  <footer>
    Powered by <span>Flovvnetic</span> | Â© SHSSS Headlines
  </footer>

<script>
/* === Same JavaScript from previous working version === */
class PDFProcessor {
  constructor() {
    this.files = [];
    this.processedPDF = null;
    document.getElementById('pdfInput').addEventListener('change', e => {
      this.files = Array.from(e.target.files);
    });
    document.getElementById('invertColors').addEventListener('change', e => {
      document.getElementById('invertOptions').style.display = e.target.checked ? "block" : "none";
    });
  }

  updateProgress(percent, text) {
    document.getElementById('progressFill').style.width = percent + "%";
    document.getElementById('statusText').innerText = text;
  }

  async start() {
    if (!this.files.length) {
      alert("Upload at least one PDF!");
      return;
    }
    this.updateProgress(0, "Starting...");
    await this.performProcessing();
  }

  async performProcessing() {
    this.updateProgress(10, 'Loading PDFs...');
    const pdfDocs = [];
    for (let i = 0; i < this.files.length; i++) {
      const arrayBuffer = await this.files[i].arrayBuffer();
      const pdfDoc = await PDFLib.PDFDocument.load(arrayBuffer);
      pdfDocs.push(pdfDoc);
      this.updateProgress(10 + (i+1) * 20/this.files.length, `Loaded PDF ${i+1}`);
    }

    let resultDoc;
    if (document.getElementById('mergePDF').checked && pdfDocs.length > 1) {
      resultDoc = await PDFLib.PDFDocument.create();
      for (const pdfDoc of pdfDocs) {
        const pageCount = pdfDoc.getPageCount();
        const pages = await resultDoc.copyPages(pdfDoc, Array.from({length: pageCount}, (_,i)=>i));
        pages.forEach(p => resultDoc.addPage(p));
      }
    } else {
      resultDoc = pdfDocs[0];
    }

    this.updateProgress(50, 'Applying transformations...');
    resultDoc = await this.applyAdvancedProcessing(resultDoc);

    if (document.getElementById('splitPDF').checked) {
      this.updateProgress(75, 'Splitting...');
      const splitPage = parseInt(document.getElementById('splitPage').value);
      const pageCount = resultDoc.getPageCount();
      if (splitPage > 1 && splitPage <= pageCount) {
        const splitDoc = await PDFLib.PDFDocument.create();
        const pages = await splitDoc.copyPages(resultDoc, Array.from({length: pageCount - splitPage + 1}, (_,i)=>splitPage-1+i));
        pages.forEach(p => splitDoc.addPage(p));
        for (let i = pageCount-1; i >= splitPage-1; i--) resultDoc.removePage(i);
      }
    }

    this.updateProgress(90, 'Finalizing...');
    this.processedPDF = await resultDoc.save();
    this.preview();
    document.getElementById('downloadBtn').disabled = false;
    this.updateProgress(100, 'Done!');
  }

  async applyAdvancedProcessing(pdfDoc) {
    const newPdf = await PDFLib.PDFDocument.create();
    const pdfBytes = await pdfDoc.save();
    const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;

    const perSheet = parseInt(document.getElementById("multiplePages").value);
    let sheetCanvas = document.createElement("canvas");
    let ctx = sheetCanvas.getContext("2d");
    let sheetCount = 0;

    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const viewport = page.getViewport({ scale: 2 });
      const canvas = document.createElement("canvas");
      const ctxPage = canvas.getContext("2d");
      canvas.width = viewport.width;
      canvas.height = viewport.height;
      await page.render({ canvasContext: ctxPage, viewport }).promise;

      if (document.getElementById("invertColors").checked) {
        const invertLevel = document.querySelector("input[name='invertLevel']:checked").value;
        const imageData = ctxPage.getImageData(0, 0, canvas.width, canvas.height);
        let d = imageData.data;
        for (let j = 0; j < d.length; j+=4) {
          d[j] = 255 - d[j];
          d[j+1] = 255 - d[j+1];
          d[j+2] = 255 - d[j+2];
          if (invertLevel === "3") {
            let avg = (d[j] + d[j+1] + d[j+2])/3;
            let bw = avg > 128 ? 255 : 0;
            d[j] = d[j+1] = d[j+2] = bw;
          }
        }
        ctxPage.putImageData(imageData, 0, 0);
      }

      if (perSheet === 1) {
        const imgBytes = await this.canvasToBytes(canvas);
        const pageImg = await newPdf.embedJpg(imgBytes);
        const newPage = newPdf.addPage([pageImg.width, pageImg.height]);
        newPage.drawImage(pageImg, {x:0,y:0,width:pageImg.width,height:pageImg.height});
      } else {
        if (sheetCount % perSheet === 0) {
          sheetCanvas = document.createElement("canvas");
          ctx = sheetCanvas.getContext("2d");
          sheetCanvas.width = viewport.width * (perSheet === 4 ? 2 : 1);
          sheetCanvas.height = viewport.height * (perSheet === 4 ? 2 : 1);
        }
        let posX = (sheetCount % perSheet === 1 || sheetCount % perSheet === 3) ? viewport.width : 0;
        let posY = (sheetCount % perSheet >= 2) ? viewport.height : 0;
        ctx.drawImage(canvas, posX, posY, viewport.width, viewport.height);
        if ((sheetCount % perSheet) === perSheet-1 || i === pdf.numPages) {
          const imgBytes = await this.canvasToBytes(sheetCanvas);
          const pageImg = await newPdf.embedJpg(imgBytes);
          const newPage = newPdf.addPage([pageImg.width, pageImg.height]);
          newPage.drawImage(pageImg, {x:0,y:0,width:pageImg.width,height:pageImg.height});
        }
        sheetCount++;
      }
    }
    return newPdf;
  }

  async canvasToBytes(canvas) {
    return await new Promise(resolve => canvas.toBlob(b => {
      const reader = new FileReader();
      reader.onload = () => resolve(new Uint8Array(reader.result));
      reader.readAsArrayBuffer(b);
    }, "image/jpeg", document.getElementById("qualitySlider").value/100));
  }

  preview() {
    const blob = new Blob([this.processedPDF], { type: "application/pdf" });
    const url = URL.createObjectURL(blob);
    document.getElementById("pdfPreview").src = url;
  }

  download() {
    const blob = new Blob([this.processedPDF], { type: "application/pdf" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "processed.pdf";
    a.click();
  }
}
const processor = new PDFProcessor();
</script>
</body>
</html>
